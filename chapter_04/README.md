# Chapter 04. 카프카 컨슈머: 카프카에서 데이터 읽기
## 4.1 카프카 컨슈머: 개념
### 4.1.1 컨슈머와 컨슈머 그룹
* 카프카 컨슈머는 컨슈머 그룹의 일부로서 작동한다.
* 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우, 각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메시지를 받는 것이다.
* 만약 하나의 토픽을 구독하는 하나의 컨슈머 그룹에 파티션 수보다 더 많은 컨슈머를 추가한다면, 컨슈머 중 몇몇은 유휴 상태가 되어 메시지를 전혀 받지 못한다.
  * 즉, 토픽에 설정된 파티션 수 이상으로 컨슈머를 투입하는 것은 의미가 없다.
* 카프카의 주 디자인 목표 중 하나는 카프카 토픽에 쓰여진 데이터를 전체 조직 안에서 여러 용도로 사용할 수 있도록 만드는 것이다.
  * 이를 위해 애플리케이션이 각자 컨슈머 그룹을 갖도록 하면 된다.

### 4.1.2 컨슈머 그룹과 파티션 리밸런스
* 새로운 컨슈머를 컨슈머 그룹에 추가하면 이전에 다른 컨슈머가 읽고 있던 파티션으로부터 메시지를 읽기 시작한다.
* 해당 컨슈머가 컨슈머 그룹에서 나가면 원래 이 컨슈머가 읽던 파티션들은 그룹에 잔류한 나머지 컨슈머 중 하나가 대신 받아서 읽기 시작한다.
* 컨슈머에 파티션을 재할당하는 작업은 컨슈머 그룹이 읽고 있는 토픽이 변경되었을 때도 발생한다.
* 컨슈머에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업을 리밸런스라고 한다.

#### Eager Rebalance (조급한 리밸런스)
* 모든 컨슈머는 읽기 작업을 멈추고 자신에게 할당된 모든 파티션에 대한 서유권을 포기한 뒤, 컨슈머 그룹에 다시 참여하여 완전히 새로운 파티션 할당을 전달받는다.
* 전체 컨슈머 그룹에 대해 짧은 시간 동안 다운 타임이 발생한다.
  * 다운 타임의 길이는 컨슈머 그룹의 크기와 여러 설정 매개 변수에 영향을 받는다.

#### Cooperative Rebalance (협조적 리밸런스) (or Incremental Rebalance, 점진적 리밸런스)
* 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에게 재할당한다.
  * 즉, 재할당되지 않은 파티션에 대해 메시지를 처리하던 컨슈머들은 다운 타임이 발생하지 않는다.
* 이 경우에 리밸런싱은 2개 이상의 단계에 걸쳐서 수행된다.
  * 첫 번재 단계는 컨슈머 그룹 리더가 다른 컨슈머들에게 각자에게 할당된 파티션 중 일부가 재할당될 것이라고 통보하면, 컨슈머들은 해당 파티션에서 데이터를 읽어오는 작업을 멈추고 해당 파티션에 대한 소유권을 포기한다.
  * 두 번째 단계는 컨슈머 그룹 리더가 이 포기된 파티션들을 새로 할당한다.
* 파티션이 할당될 때까지 몇 번 반복될 수 있지만, 전체 작업이 중단되는 사태는 발생하지 않는다.
* 리밸런싱 작업에 상당한 시간이 걸릴 위험이 있는, 컨슈머 그룹에 속한 컨슈머 수가 많은 경우에 중요하다.
* 컨슈머는 해당 컨슈머 그룹의 그룹 코디네이터 역할을 지정받은 카프카 브로커(컨슈머 그룹별로 다를 수 있다)에 하트비트를 전송함으로써 멤버쉽과 할당된 파티션에 대한 소유권을 유지한다.
* 하트비트는 컨슈머의 백그라운드 스레드에 의해 전송되고, 일정한 간격을 두고 전송되는 한 연결이 유지되고 있는 것으로 간주된다.
* 컨슈머가 일정 시간 이상 하트비트를 전송하지 않는다면, 세션 타임아웃이 발생하면서 그룹 코디네이터는 해당 컨슈머가 다운됐다고 간주하고 리밸런싱을 시작한다.
* 컨슈머를 깔끔하게 닫아줄 경우 컨슈머는 그룹 코디네이터에게 그룹을 나간다고 통지하는데, 그룹 코디네이터는 즉시 리밸런스를 실행함으로써 처리가 정지되는 시간을 줄인다.
* 2.4 버전 이후로는 Eager Rebalance가 기본값이었지만, 3.1부터는 Coorperative Rebalance가 기본값이다.

### 4.1.3 정적 그룹 멤버십
* 컨슈머가 갖는 컨슈머 그룹의 멤버로서의 자격은 일시적이다.
* 컨슈머가 컨슈머 그룹을 나가는 순간 해당 컨슈머에 할당되어 있던 파티션들은 해체되고, 다시 참여하면 새로운 멤버 ID가 발급되면서 리밸런스 프로토콜에 의해 새로운 파티션들이 할당되는 것이다.
* 위 설명은 group.instance.id 값을 잡아 주지 않는 한 유효하다.
* 컨슈머가 정적 멤버로서 컨슈머 그룹에 처음 참여하면 평소와 같이 해당 그룹이 사용하고 있는 파티션 할당 전략에 따라 파티션이 할당된다.
  * 하지만 이 컨슈머가 꺼질 경우, 자동으로 그룹을 떠나지는 않는다. (세션 타임아웃이 경과될 때까지 여전히 그룹 멤버로 남아있게 되는 것이다.)
  * 그리고 컨슈머가 다시 그룹에 조인하면 멤버십이 그대로 유지되기 때문에 리밸런스가 발생할 필요 없이 파티션을 그대로 재할당 받는다.
  * 그룹 코디네이터는 그룹 내 각 멤버에 대한 파티션 할당을 캐시해 두고 있기 때문에 정적 멤버가 다시 조인해 들어온다고 해서 리밸런스를 발생시키지는 않는다.
* 컨슈머 그룹의 정적 멤버가 종료되었음을 알아차리는 것은 session.timeout.ms 설정에 달려 있다.
  * 이 값은 단순한 애플리케이션 재시작이 리밸런싱을 작동시키지 않을 만큼 충분히 크면서, 시간 동안 작동이 멈출 경우 자동으로 파티션 재할당이 이루어져서 오랫동안 파티션 처리가 멈추는 상황을 막을 수 있을 만큼 충분히 작언 값으로 설정 해아한다.

## 4.4 폴링 루프
* 컨슈머 API는 서버에 추가 데이터가 들어왔는지 폴링하는 단순한 루프를 돈다.
* 컨슈머가 카프카를 계속해서 폴링하지 않으면 죽은 것으로 간주되어 해당 컨슈머가 읽던 파티션들이 그룹 내의 다른 컨슈머에게 넘겨진다.
* 컨슈머는 poll() 메서드를 호출해서 데이터를 읽어온다.
  * poll()에 전달하는 매개변수는 컨슈머 버퍼에 데이터가 없을 경우 poll()이 블록될 수 있는 최대 시간을 결정한다.
  * 이 값이 0으로 지정되거나 버퍼 안에 이미 레코드가 준비되어 있을 경우 poll()은 즉시 리턴된다. 아닌 경우에는 지정된 밀리초만큼 대기한다.
* 새 컨슈머에서 처음으로 poll()을 호출하면 컨슈머는 GroupCoordinator를 찾아서 컨슈머 그룹에 참가하고, 파티션을 할당 받는다.
* poll()이 max.poll.interval.ms에 지정된 시간 이상으로 호출되지 않을 경우, 컨슈머는 죽은 것으로 판정되어 컨슈머 그룹에서 퇴출된다.
  * 따라서 폴링 루프 안에서 예측 불가능한 시간 동안 블록되는 작업을 수행하는 것은 피하는 것이 좋다.

### 4.4.1 스레드 안정성
* 하나의 스레드에서 동일한 그룹 내에 여러 개의 컨슈머를 생성할 수 없다.
* 같은 컨슈머를 다수의 스레드가 안전하게 사용할 수 없다.
* 하나의 스레드당 하나의 컨슈머가 원칙이다.
* 하나의 애플리케이션에서 동일한 그룹에 속하는 여러 개의 컨슈머를 운용하고 싶다면 스레드를 여러 개 띄워서 각각의 컨슈머를 하나씩 돌려야 한다.
* 이벤트를 받아서 큐에 넣는 컨슈머 하나와 이 큐에서 이벤트를 꺼내서 처리하는 여러 개의 워커 스레드를 활용하는 방법도 있다.

### 4.5.1 fetch.min.bytes
* 컨슈머가 브로커로부터 레코드를 읽어올 때 받는 데이터의 최소량(Byte)를 지정한다.
  * 만약 브로커가 컨슈머로부터 레코드 요청을 받았는데 새로 보낼 레코드의 양이 fetch.min.bytes보다 작을 경우, 브로커는 충분한 메시지를 보낼 수 있을 때까지 기다린 뒤 컨슈머에게 레코드를 보낸다.

### 4.5.2 fetch.max.wait.ms
* fetch.min.bytes는 카프카가 컨슈머에게 응답하기 전 충분한 데이터가 모일 때까지 기다리도록 한다.
* fetch.max.wait.ms는 얼마나 오래 기다릴 것인지를 결정한다. (기본값은 500ms)

### 4.5.3 fetch.max.bytes
* 컨슈머가 브로커를 폴링할 때 카프카가 티런하는 최대 바이트 수를 지정한다. (기본값은 50MB)

### 4.5.4 max.poll.records
* poll()을 호출할 때마다 리턴되는 최대 레코드 수를 지정한다.

### 4.5.6 session.timeout.ms 그리고 heartbeat.interval.ms
* 컨슈머가 브로커와 신호를 주고받지 않고도 살아 있는 것으로 판정되는 최대 시간의 기본값은 45초다.
* 컨슈머가 그룹 코디네이터에게 하트비트를 보내지 않은 채고 session.timeout.ms가 지나가면 그룹 코디네이터는 해당 컨슈머를 죽은 것으로 간주하고, 죽은 컨슈머에게 할당되어 있던 파티션들을 다른 컨슈머에게 할당해주기 위해 리밸런스를 실행한다.
  * 이 속성은 그룹 코디네이터에게 하트비트를 얼마나 자주 보내는지를 결정하는 heartbeat.interval.ms 속성과 연관되어 있다.
  * session.timeout.ms가 컨슈머가 하트비트를 보내지 않을 수 있는 최대 시간을 결정한다.
  * heartbeat.interval.ms는 session.timeout.ms보다 더 낮은 값이어야 하며 보통 1/3으로 결정한다.

### 4.5.7 max.poll.interval.ms
* 컨슈머가 폴링을 하지 않고도 죽은 것으로 판단하지 않을 수 있는 최대 시간을 지정한다.
* 하트비트와 세션 타임아웃은 카프카가 죽은 컨슈머를 찾아내고 할당된 파티션을 해제할 수 있게 해주는 주된 메커니즘이다.
  * 차이점은 하트비트는 백그라운드 스레드에 의해 전송된다.
  * 카프카에서 레코드를 읽어오는 메인 스레드는 데드락이 걸렸는데 백그라운스 스레드는 멀쩡히 하트비트를 전송하고 있을 수도 있다.
  * 이는 이 컨슈머에 할당된 파티션의 레코드들이 처리되고 있지 않음을 의미한다.
  * 컨슈머가 여전히 레코드를 처리하고 있는지의 여부를 확인하는 가장 쉬운 방법은 컨슈머가 추가로 메시지를 요청하는지를 확인하는 것이다.
* 기본값은 5분이다.
* 타임아웃이 발생하면 백그라운드 스레드는 브로커로 하여금 컨슈머가 죽어서 리밸런스가 수행되어야 한다는 걸 알 수 있도록 'leave group' 요청을 보낸 뒤, 하트비트 전송을 중단한다.

### 4.5.8 default.api.timeout.ms
* API를 호출할 때 명시적인 타임아웃을 지정하지 않는 한, 거의 모든 컨슈머 API 호출에 적용되는 타임아웃 값이라고 할 수 있다.
* 기본값은 1분이며, 이 값이 요청 타임아웃 기본값보다 크기 때문에 필요할 경우 이 시간 안에 재시도를 할 수 있다.
* 이 값이 적용되지 않는 예외로는 poll() 메서드가 있는데, 이 메서드는 언제나 명시적으로 타임아웃을 지정해 줘야 한다.

### 4.5.9 request.timeout.ms
* 컨슈머가 브로커로부터의 응답을 기다릴 수 있는 최대 시간이다.
* 브로커가 이 설정된 시간 안에 응답하지 않을 경우, 클라이언트는 브로커가 응답하지 않을 것이라고 간주하고 연결을 닫은 뒤 재연결을 시도한다.
* 기본값은 30초이다.

### 4.5.10 auto.offset.reset
* 컨슈머가 예전에 오프셋을 커밋한 적이 없거나, 커밋된 오프셋이 유효하지 않을 때, 파티션을 읽기 시작할 때의 작동을 정의한다.
  * 대개 컨슈머가 오랫동안 읽은 적이 없어서 오프셋의 레코드가 이미 브로커에서 삭제된 경우다.
* 기본값은 'latest'인데, 만약 유효한 오프셋이 없을 경우 컨슈머가 작동하기 시작한 다음부터 쓰여진 레코드부터 읽기 시작한다.
* 다른 값으로는 'earliest'가 있는데, 유효한 오프셋이 없을 경우 파티션의 맨 처음부터 모든 데이터를 읽는 방식이다.
* 'none'으로 설정된 상태에서 유효하지 않은 오프셋부터 읽으려고 하는 경우에 예외가 발생한다.

### 4.5.11 enable.auto.commit
* 이 매개변수는 컨슈머가 자동으로 오프셋을 커밋할지의 여부를 결정한다. 기본값은 true다.
* 언제 오프셋을 커밋할지를 직접 결정(중복을 최소화하고 유실되는 데이터를 방지하려면 필요하다.)하고 싶다면 false로 설정하면 된다.
* true인 경우, auto.commit.interval.ms를 사용해서 얼마나 자주 오프셋이 커밋될지를 제어할 수 있다.

### 4.5.12 partition.assignment.strategy
* PartitionAssignor 클래스는 컨슈머와 이들이 구독할 토픽들이 주어졌을 때 어느 컨슈머에게 어느 파티션이 할당될지를 결정하는 역할을 한다.

#### Range
* 컨슈머가 구독하는 각 토픽의 파티션들을 연속된 그룹으로 나눠서 할당한다.
* 컨슈머 C1, C2가 각각 3개의 파티션을 갖는 토픽 T1, T2를 구독했을 경우, C1은 T1과 T2의 0번, 1번 파티션을 할당받고, C2는 두 토픽의 2번 파티션을 할당받는다.
  * 각 토픽의 홀수 개의 파티션을 가지고 있고 각 토픽의 할당이 독립적으로 이루어지기 때문에 첫 번째 컨슈머는 두 번째 컨슈머보다 더 많은 파티션을 할당받게 된다.\
  * 각 토픽의 파티션 수가 컨슈머 수로 깔끔하게 나눠떨어지지 않는 상황에서 Range 할당 전략이 사용되는 한 언제든지 발생할 수 있다.

#### RoundRobin
* 모든 구독된 토픽의 모든 파티션을 가져다 순차적으로 하나씩 컨슈머에 할당해 준다.
* 앞의 C1, C2에 RoundRobin 할당을 할 경우 C1은 T1의 0번과 2번, C2의 1번 파티션을 할당받고, C2는 T1의 1번, T2의 0번, 2번 파티션을 할당받는다.
* 일반적으로 컨슈머들은 동일한 토픽을 구독하기 때문에 RoundRobin 방식을 선택할 경우 모든 컨슈머들이 완전히 동일한 수(혹은 많아야 1개 차이)의 파티션을 할당받게 된다.

#### Sticky
* Sticky 할당자는 두 개의 목표를 가지고 있다.
  * 첫 번째는 파티션들을 가능한 균등하게 할당하는 것이다.
  * 두 번째는 리밸런스가 발생했을 때 가능하면 많은 파티션들이 같은 컨슈머에 할당되게 함으로써 할당된 파티션을 하나의 컨슈머에서 다른 컨슈머로 옮길 때 발생하는 오버헤드를 최소화 하는 것이다.
* RoundRobin 전략과 비교해서 파티션 균형이 얼마나 잡히느냐의 측면에서는 크게 다르지 않지만, 이동하는 파티션의 수 측면에서는 Sticky 쪽이 더 적다.
* 같은 그룹에 속한 컨슈머들이 서로 다른 토픽을 구독할 경우, Sticky 할당자를 사용한 할당이 RoundRobin 할당자를 사용한 것보다 더 균형잡히게 된다.

#### Cooperative Sticky
* Sticky 할당자와 기본적으로 동일하지만, 컨슈머가 재할당되지 않는 파티션으로부터 레코드를 계속해서 읽어 올 수 있도록 해주는 협력적 리밸런스 기능을 지원한다.

### 4.5.13 client.id
* 어떠한 문자열도 될 수 있고, 브로커가 요청을 보낸 클라이언트를 식별하는 데 쓰인다.
* 로깅, 모니터링 지표, 쿼터에서도 사용된다.

### 4.5.14 client.rack
* 컨슈머는 각 파티션의 리더 레플리카로부터 메시지를 읽어 온다.
* 하지만 클러스터가 다수의 데이터센터 혹은 다수의 클라우드 AZ에 걸쳐 설치되어 있는 경우 컨슈머와 같은 영역에 있는 레플리카로부터 읽어 오는 것이 성능 면에서나 비용 면에서나 유리하다.
* 가장 가까운 레플리카로부터 읽어올 수 있게 할 때, 이 설정을 잡아줌으로써 클라이언트가 위치한 영역을 식별할 수 있도록 해주어야 한다.
  * 그러고 나서 브로커의 replica.selector.class 설정 기본값을 org.apache.kafka.common.replica.RackAwareReplicaSelector로 잡아주면 된다.
* 클라이언트 메타데이터와 파티션 메타데이터를 활용해서 읽기 작업에 사용할 최적의 레플리카를 선택하는 커스텀 로직을 직접 구현해 넣을 수도 있다.

### 4.5.15 group.instance.id
* 컨슈머에 정적 그룹 멤버십 기능을 적용하기 위해 사용되는 설정으로, 어떤 고유한 문자열도 사용이 가능하다.

### 4.5.16 receive.buffer.bytes, send.buffer.bytes
* 데이터를 읽거나 쓸 때 소켓이 사용하는 TCP의 수신 및 수신 버퍼의 크기를 가리킨다. -1로 설정하면 운영체제 기본값이 사용된다.

### 4.5.17 offsets.retention.minutes
* 이것은 브로커 설정이지만, 컨슈머 작동에 큰 영향을 줄 수 있다.
* 컨슈머 그룹에 현재 돌아가고 있는 컨슈머들이 있는 한, 컨슈머 그룹이 각 파티션에 대해 커밋한 마지막 오프셋 값은 카프카에 의해 보존되기 때문에 재할당이 발생하거나 재시작을 한 경우에도 가져다 쓸 수 있다.
* 하지만 그룹이 비게 된다면 카프카는 커밋된 오프셋을 이 설정값에 지정된 기간 동안만 보관한다. 기본값은 7일이다.
* 커밋된 오프셋이 삭제된 상태에서 그룹이 다시 활동을 시작하게 되면 과거에 수행했던 읽기 작업에 대한 기록이 없기 때문에 새로운 컨슈머 그룹인 것처럼 작동하게 된다.

## 4.6 오프셋과 커밋
* 그릅 내의 컨슈머는 어떤 레코드를 읽었는지 판단할 수 있다.
* 컨슈마가 카프카를 사용해서 각 파티션에서의 위치를 추적할 수 있게 한다.
* 카프카에서는 파티션에서의 현재 위치를 업데이트하는 작업을 오프셋 커밋(offset commit)이라고 부른다.
  * 카프카는 레코드를 개별적으로 커밋하지 않으며, 파티션에서 성공적으로 처리한 마지막 메시지를 커밋함으로써 그 앞의 모든 메시지들 역시 성공적으로 처리되었음을 암묵적으러 나타낸다.
* 컨슈머는 카프카 특수 토픽인 __consumer_offsets 토픽에 각 파티션별로 커밋된 오프셋을 업데이트하도록 하는 메시지를 보냄으로써 오프셋을 커밋한다.
* 컨슈머가 크래시되거나 새로운 컨슈머가 그룹에 추가될 경우 리밸런스가 발생하느넫, 리밸런스 이후 각각의 컨슈머는 이전과 다른 파티션들을 할당받을 수 있다.
  * 어디서부터 작업을 재개해야 하는지 알아내기 위해 컨슈머는 각 파티션의 마지막으로 커밋된 메시지를 읽어온 뒤 거기서부터 처리를 재개한다.
* 만약 커밋된 오프셋이 클라이언트가 처리한 마지막 메시지의 오프셋보다 작을 경우, 마지막으로 처리된 오프셋과 커밋된 오프셋 사이의 메시지들은 두 번 처리된다.
* 만약 커밋된 메시지가 클라이언트가 실제로 처리한 마지막 메시지의 오프셋보다 클 경우, 마지막으로 처리된 오프셋과 커밋된 오프셋 사이의 모든 메시지들은 컨슈머 그룹에서 누락되게 된다.

### 4.6.1 자동 커밋
* enable.auto.commit 을 true로 설정하면 컨슈머는 5초에 한 번, poll()을 통해 받은 메시지 중 마지막 메시지의 오프셋을 커밋한다.
  * 5초는 기본값으로, auto.commit.interval.ms 설정으로 바꿀 수 있다.
* 자동 커밋은 폴링 루피에 의해서 실행된다.
* 자동 커밋의 커밋 주기는 중복 처리를 유발할 가능성이 있다.
  * 5초에 한 번 자동 커밋이 발생하는 경우, 만약 마지막에 커밋한 지 3초 뒤에 컨슈머가 크래시 되었을 때, 리밸런싱이 일어나고 새로운 컨슈머가 할당받은 파티션의 마지막으로 커밋된 오프셋은 3초 전이다. 이때 중복 처리가 발생될 수 있다.
* 자동 커밋 기능이 켜진 상태에서 오프셋을 커밋할 때가 되면, 다음 번에 호출된 poll()이 이전 호출에서 리턴된 마지막 오프셋을 커밋한다.
  * 이 작동은 어느 이벤트가 실제로 처리되었는지 알지 못하기 때문에 poll()을 다시 호출하기 전 이전 호출에서 리턴된 모든 이벤트들을 처리하는 게 중요하다.

### 4.6.2 현재 오프셋 커밋하기
* enable.auto.commit 을 false 로 설정하면 애플리케이션이 명시적으로 커밋하려 할 때만 오프셋이 커밋되게 할 수 있다.
* 가장 간단하고 신뢰성 있는 커밋 API는 commitSync()다.
  * 이 API는 poll()이 리턴한 마지막 오프셋을 커밋한 뒤 커밋이 성공적으로 완료되면 리턴, 실패하면 예외를 발생시킨다.
  * commitSync()는 poll()에 의해 리턴된 마지막 오프셋을 커밋한다는 점에 유의해야 한다.
  * poll()에서 리턴된 모든 레코드의 처리가 완료되기 전 commitSync()를 호출하게 될 경우 애플리케이션이 크래시되었을 때 커밋은 되었찌만 아직 처리되지 않은 메시지들이 누락될 위험이 있다.

### 4.6.3 비동기적 커밋
* 수동 커밋의 단점 중 하나는 브로커가 커밋 요청에 응답할 때까지 애플리케이션이 블록된다는 점이다.
* 비동기적 커밋 API를 사용하면 브로커가 커밋에 응답할 때까지 기다리는 대신 요청만 보내고 처리를 계속한다.
* commitSync()가 성공하거나 재시도 불가능한 실패가 발생할 때까지 재시도하는 반면, commitAsync()는 재시도하지 않는다는 단점이 있다.
* commitAsync()는 브로커가 보낸 응답을 받았을 때 호출되는 콜백을 지정할 수 있다.
  * 콜백은 커밋 에러를 로깅하거나 커밋 에러 수를 지표 형태로 집계하기 위해 사용되는 것이 보통이지만, 재시도를 하기 위해 콜백을 사용하고자 할 경우 커밋 순서 관련된 문제에 주의해야 한다.

## 4.7 리밸런스 리스너
* 컨슈머는 종료하기 전이나 리밸런싱이 시작되기 전에 클린업을 해주어야 한다.
* 컨슈머 API는 컨슈머에 파티션이 할당되거나 해제될 때 사용자의 코드가 실행되도록 하는 메커니즘을 제공한다.
  * subscribe()를 호출할 때 ConsumerRebalanceListener 를 전달해주면 왼다.
* ConsumerRebalance 에는 아래와 같이 3개의 메서드를 구현할 수 있다.
  * public void onPartitionAssigned(Collection<TopicPartition> partitions)
    * 파티션이 컨슈머에게 재할당되고 메시지를 읽기 시작하기 전에 호출된다.
    * 컨슈머가 그룹에 문제없이 조인하려면, 여기서 수행되는 모든 준비 작업은 max.poll.timeout.ms 안에 완료되어야 한다.
  * public void onPartitionsRevoked(Collection<TopicPartition> partitions)
    * 컨슈머가 할당받았던 파티션이 할당 해제될 때 호출된다. (리밸런스 때문일 수도 있고, 컨슈머가 닫혀서일 수도 있다.)
    * 여기서 요프셋을 커밋해주어야 이 파티션을 다음에 할당받는 컨슈머가 시작할 지점을 알아낼 수 있다.
  * public void onPartitionsLost(Collection<TopicPartition> partitions)
    * 협력적 리밸런스 알고리즘이 사용되었을 경우, 할당된 파티션이 리밸런스 알고리즘에 의해 해제되기 전에 다른 컨슈머에 먼저 할당된 예외적인 상황에서만 호출된다. (일반적인 상황에서는 onPartitionsRevoked()가 호출된다.)
    * 여기서는 파티션과 함께 사용되었던 상태나 자원들을 정리해주어야 한다.
    * 파티션을 새로 할당받은 컨슈머가 이미 상태를 저장했을 수도 있기 때문에 충돌을 피해야 한다.
    * 이 메서드를 구현하지 않았을 경우, onPartitionsRevoked()가 대신 호출된다.
