# Chapter 01. 카프카 시작하기
## 1.1 발행/구독 메시지 전달
* 발행/구독 메시지 전달 패턴의 특징은 전송자가 데이터를 보낼 때 직접 수신자로 보내지 않는다.
* 전송자는 어떤 형태로든 메시지를 분류해서 보내고, 수신자는 분류된 메시지를 구독한다.
* 발행/구독 시스템에는 대개 발행된 메시지를 전달받고 중계해주는 중간 지점 역할을 하는 브로커가 있다.

### 1.2 카프카 입문
* 카프카는 '분산 커밋 로그' 혹은 '분산 스트리밍 플랫폼'이라고 불리기도 한다.
* 카프카에 저장된 데이터는 순서를 유지한 채로 지속성 있게 보관되며 결정적으로 읽을 수 있다.
* 확장시 성능을 향상시키고 실패가 발생하더라도 데이터 사용에는 문제가 없도록 시스템 안에서 데이터를 분산시켜 저장할 수 있다.

### 1.2.1 메시지와 배치
* 카프카 데이터의 기본 단위는 메시지다.
* 메시지는 단순히 바이트 배열일 뿐이기 때문에 여기에 포함된 데이터는 특정한 형식이나 의미가 없다.
* 메시지는 키(key)라고 불리는 메타데이터를 포함할 수도 있다. 키 역시 바이트 배열일 뿐이다.
* 키는 메시지를 저장할 파티션을 결정하기 위해 사용된다.
  * 가장 간단한 방법은 키값에서 일정한 해시값을 생성한 뒤 이 값을 토픽의 파티션 수로 나눴을 때 나오는 나머지 값에 해당하는 파티션에 메시지를 저장하는 것이다.
    * 파티션 수가 변하지 않는 한 항상 같은 파티션에 저장된다.
* 카프카는 효율성을 위해 메시지를 배치 단위로 저장한다.
  * 메시지를 쓸 때마다 네트워크 간에 통신이 이루어진다면 오버헤드가 발생하기 때문이다.
  * 배치는 그저 같은 토픽의 파티션에 쓰여지는 메시지들의 집합일 뿐이다. 배치를 이용하면 네트워크 부하를 줄일 수 있다.
  * 배치 단위 크기에 따라 지연과 처리량이 달라지며, 트레이드 오프를 발생시킨다.

### 1.2.2 스키마
* 카프카의 메시지는 단순 바이트 배열일 뿐이지만, 내용을 이해하기 쉽도록 일정한 구조를 부여하는 것이 권장된다.
* 필요에 따라 사용 가능한 메시지 스키마는 여러 가지가 있는데, 가장 간단하는 JSON이나 XML 포맷이 있다.

### 1.2.3 토픽과 파티션
* 카프카에 저장되는 메시지는 토픽 단위로 분류된다.
* 토픽은 다시 여러 개의 파티션으로 나뉘어진다.
* 파티션은 하나의 로그에 해당된다. 파티션에 메시지가 쓰여질 때는 추가만 가능한 형태로 쓰여지며, 읽을 때는 맨 앞부터 제일 끝까지의 순서로 읽힌다.
  * 대개 토픽에 여러 개의 파티션이 있는 만큼 토픽 안의 메시지 전체에 대해 순서는 보장되지 않으며, 단일 파티션 안에서만 순서가 보장된다.
* 파티션은 복제와 확장성을 제공한다.
  * 서로 다른 서버들이 동일한 파티션의 복제본을 저장하고 있기 때문에 서버 중 하나에 장애가 발생해도 읽거나 쓸 수 없는 상황이 벌어지지 않는다.

### 1.2.4 프로듀서와 컨슈머
* 프로듀서는 새로운 메시지를 생성한다.
  * 프로듀서는 메시지를 쓸 때 토픽에 속한 파티션들 사이에 고르게 나눠서 쓰도록 되어 있다.
  * 키와 키값의 해시를 특정 파티션으로 대응시켜 주는 파티셔너를 사용해서 특정한 파티션을 지정하여 메시지를 쓰기도 한다.
  * 프로듀서는 메시지를 파티션으로 대응시켜주는 다름의 규칙을 가진 커스텀 파티셔너를 사용할 수도 있다.
* 컨슈머는 메시지를 읽는다.
  * 컨슈머는 1개 이상의 토픽을 구독해서 여기에 저장된 메시지들을 각 파티션에 쓰여진 순서대로 읽어 온다.
  * 컨슈머는 메시지의 오프셋을 기록함으로써 어느 메시지까지 읽었는지를 유지한다. 
  * 오프셋은 지속적으로 증가하는 정수값으로, 카프카가 메시지를 저장할 때 각각의 메시지에 부여해주는 또 다른 메타데이터다.
  * 주어진 파티션의 각 메시지는 고유한 오프셋을 가지며, 뒤에 오는 메시지가 앞의 메시지보다 더 큰 오프셋을 가진다.
  * 컨슈머는 컨슈머 그룹의 일원으로서 작동한다.
  * 컨슈머 그룹은 토픽에 저장된 데이터를 읽어오기 위해 협업하는 하나 이상의 컨슈머로 이루어진다.
  * 컨슈머 중 하나에 장애가 발생하더라도, 그룹 안의 다른 컨슈머들이 장애가 발생한 컨슈머가 읽고 있던 파티션을 재할당 받은 뒤 이어서 데이터를 읽어올 수 있다.

### 1.2.5 브로커와 클러스터
* 하나의 카프카 서버를 브로커라고 부른다.
* 브로커는 프로듀서로부터 메시지를 전달받아 오프셋을 할당한 뒤 디스크 저장소에 쓴다.
* 브로커는 파티션 읽기 요청을 처리하고 발행된 메시지를 보내준다.
* 카프카 브로커는 클러스터의 일부로서 작동하도록 설계되었다.
  * 하나의 클로스터 안에 여러 개의 브로커가 포함될 수 있으며, 그중 하나의 브로커가 클러스터 컨트롤러의 역할을 하게 된다.
  * 컨트롤러는 파티션을 브로커에 할당해주거나 장애가 발생한 브로커를 모니터링하는 등의 관리 기능을 담당한다.
* 파티션은 클러스터 안의 브로커 중 하나가 담당하며, 그 브로커를 파티션 리더라고 부른다.
  * 복제된 파티션이 여러 브로커에 할당될 수도 있는데, 이들을 파티션의 팔로워라고 부른다.
  * 복제 기능은 리더 브로커에 장애가 발생했을 때 팔로워 중 하나가 리더 역할을 이어받을 수 있도록 한다.
* 모든 프로듀서는 리더 브로커에 메시지를 발행해야 하지만, 컨슈머는 리더나 팔로워 중 하나로부터 데이터를 읽어올 수 있다.
* 카프카는 일정 기간 동안 메시지를 지속성 있게 보관하는 보존 기능이 있다.
  * 특정 기간 동안 메시지를 보존하거나 파티션의 크기가 특정 사이즈에 도달할 때까지 데이터를 보존한다.
  * 이러한 한도값에 도달하면 메시지는 만료되어 삭제된다.
* 토픽에는 로그 컴팩션 기능을 설정할 수도 있는데, 같은 키를 갖는 메시지 중 가장 최신의 것만 보존되도록 한다.

### 1.2.6 다중 클러스터
* 카프카 클러스터의 복제 메커니즘은 다중 클러스터 사이에서가 아닌 하나의 클러스터 안에서만 작동하도록 설계되었다.
* 카프카 프로젝트는 데이터를 다른 클러스터로 복제하는 데 사용되는 미러메이커라는 툴을 포함한다.
* 미러메이커도 근본적으로는 큐로 연결된 카프카 컨슈머와 프로듀서에 불과하다.

## 함께 보면 좋을 페이지
* [Producer ACKS](https://www.popit.kr/kafka-%EC%9A%B4%EC%98%81%EC%9E%90%EA%B0%80-%EB%A7%90%ED%95%98%EB%8A%94-producer-acks/)
