# Chapter 03. 카프카 프로듀서: 카프카에 메시지 쓰기
## 3.1 프로듀서 개요
* 카프카에 메시지를 쓰는 작업은 ProducerRecord 객체를 생성함으로써 시작된다.
  * 레코드는 토픽과 밸류 지정은 필수지만, 키와 파티션 지정은 선택사항이다.
* ProducerRecord를 전송하는 API를 호출했을 때 프로듀서가 가장 먼저 하는 일은 키와 값 객체가 네트워크 상에서 전송될 수 있도록 직렬화해서 바이트 배열로 변환하는 과정이다.
  * 그 다음에, 만약 파티션을 명시적으로 지정하지 않았다면 해당 데이터를 파티셔너에게로 보낸다.
  * 파티셔너는 파티션을 결정하는 역할을 하는데, 그 기준은 보통 ProducerRecord 객체의 키의 값이다.
  * 파티션이 결정되면 프로듀서는 레코드들을 모은 레코드 배치에 추가한다.
  * 별도의 스레드가 이 레코드 배치를 적절한 카프카 브로커에 전송한다.
* 브로커가 메시지를 성공적으로 저장했다면, 토픽, 파티션, 그리고 해당 파티션 안에서의 레코드의 오프셋을 담은 RecordMetadata 객체를 리턴한다.
* 메시지 저장에 실패했을 경우에는 에러가 리턴된다.
* 프로듀서가 에러를 수신했을 경우, 메시지 쓰기를 포기하고 사용자에게 에러를 리턴하기 전까지 몇 번 더 재전송을 시도할 수 있다.

## 3.2 카프카 프로듀서 생성하기
* 카프카 프로듀서는 아래의 3개의 필수 속성값을 갖는다.
  * bootstrap.servers
    * 카프카 클러스터와 첫 연결을 생성하기 위해 프로듀서가 사용할 브로커의 host:port 목록이다.
    * 프로듀서가 첫 연결을 생성한 뒤 추가 정보를 받아오게 되어 있기 때문에 모든 브로커를 포함할 필요는 없다.
    * 브로커 중 하나가 작동을 정지하는 경우에도 프로듀서가 클러스터에 연결할 수 있도록 최소 2개 이상을 지정하는 것이 좋다.
  * key.serializer
    * 카프카에 쓸 레코드의 키의 값을 직렬화하기 위해 사용하는 시리얼라이저 클래스의 이름이다.
    * 카프카의 client 패키지에는 ByteArraySerializer, StringSerializer, IntegerSerializer 등이 포함되어 있다.
  * value.serializer
    * 카프카에 쓸 레코드의 밸류값을 직렬화하기 위해 사용하는 시리얼라이저 클래스의 이름이다.
* 메시지 전송 방법에는 크게 3가지 방법이 있다.
  * Fire and forget
    * 메시지를 서버에 전송만 하고 성공과 실패 여부는 신경쓰지 않는다.
  * Synchronous send
    * 카프카 프로듀서는 언제나 비동기적으로 작동하는데, 메시지를 보내면 send() 메서드는 Future 객체를 리턴한다.
    * 다음 메시지를 전송하기 전 get() 메서드를 호출해서 작업이 완료될 때까지 기다렸다가 실제 성공 여부를 확인해야 한다.
  * Asynchronous send
    * 콜백 함수와 함께 send() 메서드를 호출하면 카프카 브로커로부터 응답을 받는 시점에서 자동으로 콜백 함수가 호출된다.

### 3.3.1 동기적으로 메시지 전송하기
* 재시도 가능한 에러
  * 메시지를 다시 전송함으로써 해결될 수 있는 에러를 가리킨다. ex) 네트워크 연결 에러.
  * 메시지를 전송받은 브로커가 해당 파티션의 리더가 아닐 경우 발생하는 에러는 해당 파티션에 새 리더가 선출되고 클라이언트 메타데이터가 업데이트되면 해결될 수 있다.
    * 이런 에러가 발생했을 때 자동으로 재시도하도록 KafkaProducer를 설정할 수 있고, 이 경우 재전송 횟수가 소진되고서도 에러가 해결되지 않은 경우에 한해 재시도 가능한 예외가 발생한다.
* 재시도 불가능한 에러
  * 메시지 크기가 너무 클 경우. 이런 경우는 KafkaProducer는 재시도 없이 바로 예외를 발생시킨다.

### 3.3.2 비동기적으로 메시지 전송하기
* 대부분의 현실에서 전송한 메시지에 대한 응답을 기다리는 것은 비효율적이다.
* 반대로, 메시지 전송에 완전히 실패했을 경우에는 그런 내용을 알아야 한다.
  * 그래야 사후처리를 할 수 있기 때문이다.
* 메시지를 비동기적으로 전송하고도 여전히 에러를 처리하는 경우를 위해 프로듀서는 레코드를 전송할 때 콜백을 지정할 수 있도록 한다.
* 콜백은 프로듀서의 메인 스레드에서 실행된다.
  * 만약 두 개의 메시지를 동일한 파티션에 전송한다면, 콜백 역시 보낸 순서대로 실행된다.
  * 하지만 전송되어야 할 메시지가 전송이 안되고 프로듀서가 지연되는 상황을 막기 위해서는 콜백이 충분히 빨라야 한다. 따라서 콜백 안에서 블로킹 작업을 수행하는 것 역시 권장되지 않는다.
  * 대신, 블로킹 작업을 동시에 수행하는 다른 스레드를 사용해야 한다.

## 3.4 프로듀서 설정하기
### 3.4.1 client.id
* 프로듀서와 그것을 사용하는 애플리케이션을 구분하기 위한 논리적 식별자다.
* 임의의 문자열을 사용할 수 있고, 브로커는 프로듀서가 보내온 메시지를 서로 구분하기 위해 이 값을 사용한다.
* 브로커가 로그 메시지를 출력하거나 성능 메트릭 값을 집계할 때, 그리고 클라이언트별로 사용량을 할당할 때 사용한다.

### 3.4.2 acks
* 프로듀서가 임의의 쓰기 작업이 성공했다고 판별하기 위해 얼마나 많은 파티션 레플리카가 해당 레코드를 받아야 하는지를 결정한다.
* 기본값은 리더가 해당 레코드를 받은 뒤 쓰기 작업이 성공했다고 응답하는 것이다. (3.0버전부터는 acks=all이 기본 값이다.)
* acks=0
  * 프로듀서는 메시지가 성공적으로 전달되었다고 간주하고 브로커의 응답을 기다리지 않는다.
  * 브로커가 메시지를 받지 못했을 경우에는 메시지가 유실된다.
  * 프로듀서가 서버로부터 응답을 기다리지 않으므로 네트워크가 허용하는 한 빠른 메시지 전송이 가능하다.
* acks=1
  * 프로듀서는 리더 레플리카가 메시지를 받는 순간 브로커로부터 성공했다는 응답을 받는다.
  * 리더에 메시지를 쓸 수 없는 상황이라면 프로듀서는 에러 응답을 받게 되므로, 데이터의 유실을 피하기 위해 메시지 재전송을 시도하게 된다.
  * 리더에 크래시가 난 상태에서 해당 메시지가 복제가 안 된 채로 새 리더가 선출될 경우에는 메시지가 유실될 수 있다.
* acks=all(-1)
  * 프로듀서는 메시지가 모든 인-싱크 레플리카(ISR)에 전달된 뒤에야 브로커로부터 성공했다는 응답을 받는다.
  * 메시지 유실 가능성이 가장 적다.
  * ISR에 모두 전달될 때까지 대기해야 하기 때문에, 지연 시간은 더 길어진다.
* 위 옵션들은 신뢰성과 지연 시간 사이의 트레이드 오프 관계가 있다.
* 컨슈머가 읽을 수 있을 때까지의 시간을 의미하는 종단 지연(end to end latency)의 경우 세 값이 모두 같다.
  * 카프카가 일관성을 유지하기 위해 ISR에 복제가 완료된 뒤에야 컨슈머가 레코드를 읽어 갈 수 있게 하기 때무니다.
  * 따라서 프로듀서 지연이 아니라 종단 지연이 주로 고려되어야 하는 경우라면 딱히 절충해야 할 것은 없다. 가장 신뢰성 있는 설정을 택해도 종단 지연은 똑같기 때문이다.

### 3.4.3 메시지 전달 시간
* 2.1 버전부터 ProducerRecord를 보낼 때 걸리는 시간을 두 구간으로 나누어 따로 처리할 수 있도록 했다.
  * send()에 대한 비동기 호출이 이뤄진 시각부터 결과를 리턴할 때까지 걸리는 시간
    * 이 시간 동안 send()를 호출한 스레드는 블록된다.
  * send()에 대한 비동기 호출이 성공적으로 리턴한 시각부터 콜백이 호출될 때까지 걸리는 시간
    * ProducerRecord가 전송을 위해 배치에 추가된 시점에서부터 카프카가 성공 응답을 보내거나, 재시도 불가능한 실패가 일어나거나, 아니면 전송을 위해 할당된 시간이 소진될 때까지의 시간과 동일하다.
* max.block.ms
  * send()를 호출하고 프로듀서의 전송 버퍼가 가득 차거나 메타데이터가 아직 사용 가능하지 않을 때 블록될 때, max.block.ms 만큼 시간이 흐르면 예외가 발생한다.
* delivery.timeout.ms
  * 레코드 전송 준비가 완료된 시점(send()가 문제없이 리턴되고 레코드가 배치에 저장된 시점)에서부터 브로커의 응답을 받거나 아니면 전송을 포기하게 되는 시점까지의 제한 시간을 결정한다.
  * 이 값은 linger.ms와 request.timout.ms보다 커야 한다.
  * 프로듀서가 재시도를 하는 도중에 delivery.timeout.ms가 넘어가면 마지막으로 재시도 하기 전에 브로커가 리턴한 에러에 해당하는 예외와 함께 콜백이 호출된다.
  * 레코드 배치가 전송을 기다리는 와중에 delivery.timeout.ms가 넘어가버리면 타임아웃 예외와 함께 콜백이 호출된다.
* request.timeout.ms
  * 프로듀서가 데이터를 전송할 때 서버로부터 응답을 받기 위해 얼마나 기다릴 것인지를 결정한다.
  * 각각의 쓰기 요청 후 전송을 포기하기까지 대기하는 시간이다. (재시도 시간이나, 실제 전송 이전에 소요되는 시간 등을 포함하지 않는다.)
* retries, retry.backoff.ms
  * 프로듀서가 서버로부터 에러 메시지를 받았을 때 이것이 일시적인 에러일 수도 있는데, 이때 프로듀서가 메시지 전송을 포기하고 에러를 발생시킬 때까지 메시지를 재전송하는 횟수를 결정한다.
  * 프로듀서는 각각의 재시도 사이에 100ms 동안 대기하는데, retry.backoff.ms 매개변수를 사용해서 이 간격을 조정할 수 있다.
  * 이 값들을 조정하는 것을 권장하지는 않고, 크래시가 발생한 브로커가 정상으로 돌아오기까지의 시간을 테슽한 뒤에 delivery.timeout.ms를 설정하는 것을 권장한다.
* linger.ms
  * 현재 배치를 전송하기 전까지 대기하는 시간을 결정한다.
  * 프로듀서는 배치가 가득차거나 linger.ms에 설정된 제한 시간이 되었을 때 메시지 배치를 전송한다.
  * 프로듀서는 기본적으로 메시지 전송에 사용할 수 있는 스레드가 있을 떄 곧바로 전송하도록 되어 있지만 이 값을 0보다 큰 값으로 설정하면 프로듀서가 브로커에 메시지 배치를 전송하기 전에 메시지를 더 추가할 수 있도록 할 수 있다.
  * 지연 시간을 늘리느 대신 처리율을 더 늘릴 것인지에 대한 트레이드 오프다.
* buffer memory
  * 프로듀서가 메시지를 전송하기 전에 메시지를 대기시키는 버퍼의 크기를 결정한다.
  * 애플리케이션이 서버에 전달 가능한 속도보다 더 빠르게 메시지를 전송한다면 버퍼 메모리가 가득 찰 수 잇다. 이때 추가로 호출되는 send()는 max.block.ms 동안 블록되어 버퍼 메모리에 공간이 생기기를 기다리지만, 해당 시간동안 대기해도 확보하지 못하면 예외를 발생시킨다.
* compression.type
  * 기본적으로는 메시지는 압축되지 않은 상태로 전송되지만, 이 매개변수를 통해 snappy, gzip, lz4, zstd중 하나로 압축 알고리즘을 사용할 수 있다.
* batch.size
  * 같은 파티션에 다수의 레코드가 전송될 경우 프로듀서는 이것들을 배치 단위로 모아서 한꺼번에 전송한다.
  * 이 매개변수를 통해 각각의 배치에 사용될 메모리의 양을 결정한다.
* max.in.flight.requests.per.connection
  * 프로듀서가 서버로부터 응답을 받지 못한 상태에서 전송할 수 있는 최대 메시지의 수를 결정한다.
* max.request.size
  * 프로듀서가 전송하는 쓰기 요청의 크기를 결정한다.
  * 브로커에서 받아들일 수 있는 최대 메시지 크기를 결정하는 message.max.bytes를 동일하게 맞춤으로써 프로듀서가 브로커에서 받아들이지 못하는 키기의 메시지를 전송하려 하지 않도록 하는 것이 좋다.
* receive.buffer.bytes, send.buffer.bytes
  * 데이터를 읽거나 쓸 때 소켓이 사용하는 TCP 송수신 버퍼의 크기를 결정한다.
  * -1인 경우에는 운영체제의 기본값이 사용된다.
* enable.idempotence
  * 프로듀서가 레코드를 보낼 때마다 순차적인 번호를 붙여서 보내게 하고, 브로커가 동일한 번호를 가진 레코드를 2개 이상 받을 경우 하나만 저장하게 하여 정확히 한 번 전송하는 기능을 지원하도록 한다.

## 3.6 파티션
* 카프카 메시지는 키-밸류 순서쌍이지만 키의 기본값은 null로, 토픽과 밸류의 값만 있어도 ProduceRecord 객체를 생성할 수는 있다.
* 키의 역할은 두 가지다.
  * 그 자체로 메시지에 함께 저장되는 추가적인 정보.
  * 토픽에 속한 여러 개의 파티션 중 해당 메시지가 저장될 파티션을 결정하는 기준점이다.
* 기본 파티셔너 사용 중에 키값이 null인 레코드가 주어질 경우, 레코드는 현재 사용 가능한 토픽의 파티션 중 하나에 랜덤하게 저장된다.
  * 각 파티션별로 저장되는 메시지 개수의 균형을 맞추기 위해 라운드 로빈 알고리즘이 사용된다.
* 아파치 카프카 2.4 프로듀서부터 기본 파티셔너는 키값이 null인 경우, 접착성(sticky) 처리를 하기 위해 라운드 로빈 알고리즘을 사용한다.
  * 접착성이란 프로듀서가 메시지 배치를 채울 때 다음 배치로 넘어가기 전 이전 배치를 먼저 채우는 것이다.
  * 이는 지연 시간을 줄이고 브로커의 CPU 사용량을 줄인다. (브로커로 보내야 하는 요청의 수도 줄어든다.)
* 키값이 지정된 상태에서 기본 파티셔너를 사용할 경우, 카프카는 키값을 해시한 결과를 기준으로 메시지를 저장할 파티션을 특정한다.
  * 동일한 키값은 항상 동일한 파티션에 저장되는 것이 원칙이기 때문에 파티션을 선택할 때는 토픽의 모든 파티션을 대상으로 선택한다. (즉, 사용 가능한 파티션만 대상으로 하지 않음.)
* 기본 파티셔너 외에도 카프카 클라이언트는 RoundRobinPartitioner와 UniformStickyPartitioner를 포함하고 있다.
  * 각각은 메시지가 키값을 포함하고 있을 경우에도 랜덤 파티션 할당과 접착성 랜덤 파티션 할당을 수행한다.
  * 키값 분포가 불균형해서 특정한 키값을 갖는 레코드가 많을 경우 작업 부하가 한쪽으로 몰릴 수 있는데, UniformStickyPartitioner를 사용할 경우, 전체 파티션에 대해서 균등한 분포를 가지도록 파티션이 할당된다.

### 3.6.1 커스텀 파티셔너
* 파티셔을 결정할 때, 키값을 기준으로 해시 처리해야만 하는 것은 아니다.
* 특정 메시지 특성에 따라 파티션을 결정하고 싶을 수도 있다.
  * A라는 키를 가지는 메시지가 다른 키와 달리 대량으로 발생하는 경우에, 한 파티션에 다른 파티션보다 훨씬 많은 레코드가 저장될 수 있다.
  * 이 경우 서버의 공간이 부족해지거나, 처리가 느려지는 등의 문제가 발생할 수 있다.
  * 커스텀 파티션을 이용하면 특정 파티션으로 저장되도록 할 수 있다.

## 3.7 헤더
* 레코드는 키, 밸류 외에도 헤더를 포함할 수 있다.
* 헤더는 추가 메타데이터를 심을 때 사용한다.
* 헤더는 순서가 있는 키-밸류 쌍으로 구성되며, 키는 String 타입이어야 하고, 밸류는 아무 지렬화된 객체라도 상관없다.

## 3.8 인터셉터
* 모든 애플리케이션에 동일한 작동을 집어넣는다거나 카프카 클라이언트의 코드를 고치지 않으면서 그 작동을 변경하고 싶은 경우에 ProducerInterceptor를 사용할 수 있다.
* ProducerRecord<K, V> onSend(ProducerRecord<K, V> record)
  * 프로듀서가 레코드를 브로커로 보내기 전, 직렬화되기 직전에 호출된다.
  * 이 메서드를 재정의 할 때는 보내질 레코드에 담긴 정보를 볼 수 있을 뿐만 아니라 고칠 수도 있다.
  * 메서드에서 리턴되는 레코드가 직렬화되어 카프카로 보내지게 된다.
* void onAcknowledgement(RecordMetadata metadata, Exception exception)
  * 카프카 브로커가 보낸 응답을 클라이언트가 받았을 때 호출된다.
  * 브로커가 보낸 응답을 변경할 수는 없지만, 그 안에 담긴 정보는 읽을 수 있다.
* 인터셉터의 일반적인 사용 사례로는 모니터링, 정보 추적, 표준 헤더 삽입 등이 있다.

## 3.9 쿼터, 스로틀링
* 카프카 브로커에는 쓰기/읽기 속도를 제한할 수 있는 기능이 있다.
* 쿼터(Quota)를 설정해주면 되는데, 카프카에는 다음과 같이 3가지의 쿼터 타입에 대해 한도를 설정할 수 있다.
  * 쓰기 쿼터 (produce quota)
  * 읽기 쿼터 (consume quota)
  * 요청 쿼터 (request quota)
* 쓰기 쿼터와 읽기 쿼터는 클라이언트가 데이터를 전송하거나 받는 속도를 초당 바이트 수 단위로 제한한다.
* 요청 쿼터의 경우 브로커가 요청을 처리하는 시간 비율 단위로 제한한다.
* 쿼터는 기본값을 설정하거나, 특정한 client.id 값에 대해 설정하거나 특정한 사용자에 대해 설정하거나 혹은 둘 다 설정하는 식으로 적용 가능하다.
